
module nk;

const UNDEFINED = (-1.0f);
const UTF_INVALID = 0xFFFD;
const UTF_SIZE = 4;
const INPUT_MAX = 16;
const MAX_NUMBER_BUFFER = 64;
const SCROLLBAR_HIDING_TIMEOUT = 4.0f;
const API = 0;
const LIB = 0;
const INTERN = 0;
const STORAGE = 0;
const GLOBAL = 0;

macro @flag(#x) {
  return (1 << (#x));
}

macro @stringify(#x) {}

macro @macro_stringify(#x) {}

macro @string_join_immediate(#arg1, #arg2) {}

macro @string_join_delay(#arg1, #arg2) {}

macro @string_join(#arg1, #arg2) {}

macro @unique_name(#name) {}

macro @static_assert(#exp) {}

const FILE_LINE = $$FILE +++ ":" +++ $$LINE;

macro @min(#a, #b) {}

macro @max(#a, #b) {
  return ((#a) < (#b) ? (#b) : (#a));
}

macro @clamp(#i, #v, #x) {}

macro @printf_vararg_func(#fmtargnumber) {}

macro @printf_valist_func(#fmtargnumber) {}

const INT8 = 0;
const UINT8 = 0;
const INT16 = 0;
const UINT16 = 0;
const INT32 = 0;
const UINT32 = 0;
const SIZE_TYPE = 0;
const POINTER_TYPE = 0;
const BOOL = 0;

macro @foreach(#c, #ctx) {}

macro @tree_push(#ctx, #type, #title, #state) {}

macro @tree_push_id(#ctx, #type, #title, #state, #id) {}

macro @tree_image_push(#ctx, #type, #img, #title, #state) {}

macro @tree_image_push_id(#ctx, #type, #img, #title, #state, #id) {}

macro @tree_element_push(#ctx, #type, #title, #state, #sel) {}

macro @tree_element_push_id(#ctx, #type, #title, #state, #sel, #id) {}

const WIDGET_DISABLED_FACTOR = 0.5f;
const STRTOD = 0;
const TEXTEDIT_UNDOSTATECOUNT = 99;
const TEXTEDIT_UNDOCHARCOUNT = 999;
const MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = 16;
const CHART_MAX_SLOT = 4;
const WINDOW_MAX_NAME = 64;
const BUTTON_BEHAVIOR_STACK_SIZE = 8;
const FONT_STACK_SIZE = 8;
const STYLE_ITEM_STACK_SIZE = 16;
const FLOAT_STACK_SIZE = 32;
const VECTOR_STACK_SIZE = 16;
const FLAGS_STACK_SIZE = 32;
const COLOR_STACK_SIZE = 32;

macro @configuration_stack_type(#prefix, #name, #type) {}

macro @config_stack(#type, #size) {}

const FLOAT = 0;
const VALUE_PAGE_CAPACITY = (((@max(Window.sizeof, Panel.sizeof)/Uint.sizeof))/2);
const PI = 3.141592654f;
const PI_HALF = 1.570796326f;
const MAX_FLOAT_PRECISION = 2;

macro @unused(#x) {}

macro @saturate(#x) {}

macro @len(#a) {}

macro @abs(#a) {}

macro @between(#x, #a, #b) {}

macro @inbox(#px, #py, #x, #y, #w, #h) {}

macro @intersect(#x0, #y0, #w0, #h0, #x1, #y1, #w1, #h1) {}

macro @contains(#x, #y, #w, #h, #bx, #by, #bw, #bh) {}

macro @vec2_sub(#a, #b) {}

macro @vec2_add(#a, #b) {}

macro @vec2_len_sqr(#a) {}

macro @vec2_muls(#a, #t) {}

macro @ptr_add(#t, #p, #i) {}

macro @ptr_add_const(#t, #p, #i) {}

macro @zero_struct(#s) {}

macro @uint_to_ptr(#x) {}

macro @ptr_to_uint(#x) {}

macro @align_ptr(#x, #mask) {}

macro @align_ptr_back(#x, #mask) {}

macro @offsetof(#st, #m) {}

macro @alignof(#t) {}

macro @container_of(#ptr, #type, #member) {}

alias Char = ichar;

alias Uchar = char;

alias Byte = char;

alias Short = CShort;

alias Ushort = CUShort;

alias Int = CInt;

alias Uint = CUInt;

alias Size = CULong;

alias Ptr = CULong;

alias Bool = bool;

alias Hash = Uint;

alias Flags = Uint;

alias Rune = Uint;

alias _DummyArray437 = CChar[1];

alias _DummyArray438 = CChar[1];

alias _DummyArray439 = CChar[1];

alias _DummyArray440 = CChar[1];

alias _DummyArray441 = CChar[1];

alias _DummyArray442 = CChar[1];

alias _DummyArray443 = CChar[1];

alias _DummyArray444 = CChar[1];

alias _DummyArray445 = CChar[1];

alias _DummyArray447 = CChar[1];

const CUInt FALSE = 0;
const CUInt TRUE = 1;

struct Color {
  Byte r;
  Byte g;
  Byte b;
  Byte a;
}

struct Colorf {
  float r;
  float g;
  float b;
  float a;
}

struct Vec2 {
  float x;
  float y;
}

struct Vec2i {
  CShort x;
  CShort y;
}

struct Rect {
  float x;
  float y;
  float w;
  float h;
}

struct Recti {
  CShort x;
  CShort y;
  CShort w;
  CShort h;
}

alias Glyph = CChar[4];

union Handle {
  void* ptr;
  CInt id;
}

struct Image {
  Handle handle;
  Ushort w;
  Ushort h;
  Ushort[4] region;
}

struct NineSlice {
  Image img;
  Ushort l;
  Ushort t;
  Ushort r;
  Ushort b;
}

struct Cursor {
  Image img;
  Vec2 size;
  Vec2 offset;
}

struct Scroll {
  Uint x;
  Uint y;
}

typedef Heading = inline CUInt;
const Heading UP = 0;
const Heading RIGHT = 1;
const Heading DOWN = 2;
const Heading LEFT = 3;

typedef ButtonBehavior = inline CUInt;
const ButtonBehavior BUTTON_DEFAULT = 0;
const ButtonBehavior BUTTON_REPEATER = 1;

typedef Modify = inline CUInt;
const Modify FIXED = FALSE;
const Modify MODIFIABLE = TRUE;

typedef Orientation = inline CUInt;
const Orientation VERTICAL = 0;
const Orientation HORIZONTAL = 1;

typedef CollapseStates = inline CUInt;
const CollapseStates MINIMIZED = FALSE;
const CollapseStates MAXIMIZED = TRUE;

typedef ShowStates = inline CUInt;
const ShowStates HIDDEN = FALSE;
const ShowStates SHOWN = TRUE;

typedef ChartType = inline CUInt;
const ChartType CHART_LINES = 0;
const ChartType CHART_COLUMN = 1;
const ChartType CHART_MAX = 2;

typedef ChartEvent = inline CUInt;
const ChartEvent CHART_HOVERING = 0x01;
const ChartEvent CHART_CLICKED = 0x02;

typedef ColorFormat = inline CUInt;
const ColorFormat RGB = 0;
const ColorFormat RGBA = 1;

typedef PopupType = inline CUInt;
const PopupType POPUP_STATIC = 0;
const PopupType POPUP_DYNAMIC = 1;

typedef LayoutFormat = inline CUInt;
const LayoutFormat DYNAMIC = 0;
const LayoutFormat STATIC = 1;

typedef TreeType = inline CUInt;
const TreeType TREE_NODE = 0;
const TreeType TREE_TAB = 1;

alias PluginAlloc = fn void*(
  Handle, 
  void* old, 
  Size);

alias PluginFree = fn void(
  Handle, 
  void* old);

alias PluginFilter = fn Bool(
  TextEdit*, 
  Rune unicode);

alias PluginPaste = fn void(
  Handle, 
  TextEdit*);

alias PluginCopy = fn void(
  Handle, 
  CChar*, 
  CInt len);

struct Allocator {
  Handle userdata;
  PluginAlloc alloc;
  PluginFree free;
}

typedef SymbolType = inline CUInt;
const SymbolType SYMBOL_NONE = 0;
const SymbolType SYMBOL_X = 1;
const SymbolType SYMBOL_UNDERSCORE = 2;
const SymbolType SYMBOL_CIRCLE_SOLID = 3;
const SymbolType SYMBOL_CIRCLE_OUTLINE = 4;
const SymbolType SYMBOL_RECT_SOLID = 5;
const SymbolType SYMBOL_RECT_OUTLINE = 6;
const SymbolType SYMBOL_TRIANGLE_UP = 7;
const SymbolType SYMBOL_TRIANGLE_DOWN = 8;
const SymbolType SYMBOL_TRIANGLE_LEFT = 9;
const SymbolType SYMBOL_TRIANGLE_RIGHT = 10;
const SymbolType SYMBOL_PLUS = 11;
const SymbolType SYMBOL_MINUS = 12;
const SymbolType SYMBOL_TRIANGLE_UP_OUTLINE = 13;
const SymbolType SYMBOL_TRIANGLE_DOWN_OUTLINE = 14;
const SymbolType SYMBOL_TRIANGLE_LEFT_OUTLINE = 15;
const SymbolType SYMBOL_TRIANGLE_RIGHT_OUTLINE = 16;
const SymbolType SYMBOL_MAX = 17;

fn Bool init_fixed(
  Context*, 
  void* memory, 
  Size size, 
  UserFont*)
@extern("nk_init_fixed");

fn Bool init(
  Context*, 
  Allocator*, 
  UserFont*)
@extern("nk_init");

fn Bool init_custom(
  Context*, 
  Buffer* cmds, 
  Buffer* pool, 
  UserFont*)
@extern("nk_init_custom");

fn void clear(
  Context*)
@extern("nk_clear");

fn void free(
  Context*)
@extern("nk_free");

fn void set_user_data(
  Context*, 
  Handle handle)
@extern("nk_set_user_data");

typedef Keys = inline CUInt;
const Keys KEY_NONE = 0;
const Keys KEY_SHIFT = 1;
const Keys KEY_CTRL = 2;
const Keys KEY_DEL = 3;
const Keys KEY_ENTER = 4;
const Keys KEY_TAB = 5;
const Keys KEY_BACKSPACE = 6;
const Keys KEY_COPY = 7;
const Keys KEY_CUT = 8;
const Keys KEY_PASTE = 9;
const Keys KEY_UP = 10;
const Keys KEY_DOWN = 11;
const Keys KEY_LEFT = 12;
const Keys KEY_RIGHT = 13;
const Keys KEY_TEXT_INSERT_MODE = 14;
const Keys KEY_TEXT_REPLACE_MODE = 15;
const Keys KEY_TEXT_RESET_MODE = 16;
const Keys KEY_TEXT_LINE_START = 17;
const Keys KEY_TEXT_LINE_END = 18;
const Keys KEY_TEXT_START = 19;
const Keys KEY_TEXT_END = 20;
const Keys KEY_TEXT_UNDO = 21;
const Keys KEY_TEXT_REDO = 22;
const Keys KEY_TEXT_SELECT_ALL = 23;
const Keys KEY_TEXT_WORD_LEFT = 24;
const Keys KEY_TEXT_WORD_RIGHT = 25;
const Keys KEY_SCROLL_START = 26;
const Keys KEY_SCROLL_END = 27;
const Keys KEY_SCROLL_DOWN = 28;
const Keys KEY_SCROLL_UP = 29;
const Keys KEY_MAX = 30;

typedef Buttons = inline CUInt;
const Buttons BUTTON_LEFT = 0;
const Buttons BUTTON_MIDDLE = 1;
const Buttons BUTTON_RIGHT = 2;
const Buttons BUTTON_DOUBLE = 3;
const Buttons BUTTON_MAX = 4;

fn void input_begin(
  Context*)
@extern("nk_input_begin");

fn void input_motion(
  Context*, 
  CInt x, 
  CInt y)
@extern("nk_input_motion");

fn void input_key(
  Context*, 
  Keys, 
  Bool down)
@extern("nk_input_key");

fn void input_button(
  Context*, 
  Buttons, 
  CInt x, 
  CInt y, 
  Bool down)
@extern("nk_input_button");

fn void input_scroll(
  Context*, 
  Vec2 val)
@extern("nk_input_scroll");

fn void input_char(
  Context*, 
  CChar)
@extern("nk_input_char");

fn void input_glyph(
  Context*, 
  Glyph)
@extern("nk_input_glyph");

fn void input_unicode(
  Context*, 
  Rune)
@extern("nk_input_unicode");

fn void input_end(
  Context*)
@extern("nk_input_end");

typedef AntiAliasing = inline CUInt;
const AntiAliasing ANTI_ALIASING_OFF = 0;
const AntiAliasing ANTI_ALIASING_ON = 1;

typedef ConvertResult = inline CUInt;
const ConvertResult CONVERT_SUCCESS = 0;
const ConvertResult CONVERT_INVALID_PARAM = 1;
const ConvertResult CONVERT_COMMAND_BUFFER_FULL = @flag(1);
const ConvertResult CONVERT_VERTEX_BUFFER_FULL = @flag(2);
const ConvertResult CONVERT_ELEMENT_BUFFER_FULL = @flag(3);

struct DrawNullTexture {
  Handle texture;
  Vec2 uv;
}

struct ConvertConfig {
  float global_alpha;
  AntiAliasing line_AA;
  AntiAliasing shape_AA;
  CUInt circle_segment_count;
  CUInt arc_segment_count;
  CUInt curve_segment_count;
  DrawNullTexture tex_null;
  void* vertex_layout;
  Size vertex_size;
  Size vertex_alignment;
}

fn Command* _begin(
  Context*)
@extern("nk__begin");

fn Command* _next(
  Context*, 
  Command*)
@extern("nk__next");

typedef PanelFlags = inline CUInt;
const PanelFlags WINDOW_BORDER = @flag(0);
const PanelFlags WINDOW_MOVABLE = @flag(1);
const PanelFlags WINDOW_SCALABLE = @flag(2);
const PanelFlags WINDOW_CLOSABLE = @flag(3);
const PanelFlags WINDOW_MINIMIZABLE = @flag(4);
const PanelFlags WINDOW_NO_SCROLLBAR = @flag(5);
const PanelFlags WINDOW_TITLE = @flag(6);
const PanelFlags WINDOW_SCROLL_AUTO_HIDE = @flag(7);
const PanelFlags WINDOW_BACKGROUND = @flag(8);
const PanelFlags WINDOW_SCALE_LEFT = @flag(9);
const PanelFlags WINDOW_NO_INPUT = @flag(10);

fn Bool begin(
  Context* ctx, 
  CChar* title, 
  Rect bounds, 
  Flags flags)
@extern("nk_begin");

fn Bool begin_titled(
  Context* ctx, 
  CChar* name, 
  CChar* title, 
  Rect bounds, 
  Flags flags)
@extern("nk_begin_titled");

fn void end(
  Context* ctx)
@extern("nk_end");

fn Window* window_find(
  Context* ctx, 
  CChar* name)
@extern("nk_window_find");

fn Rect window_get_bounds(
  Context* ctx)
@extern("nk_window_get_bounds");

fn Vec2 window_get_position(
  Context* ctx)
@extern("nk_window_get_position");

fn Vec2 window_get_size(
  Context* ctx)
@extern("nk_window_get_size");

fn float window_get_width(
  Context* ctx)
@extern("nk_window_get_width");

fn float window_get_height(
  Context* ctx)
@extern("nk_window_get_height");

fn Panel* window_get_panel(
  Context* ctx)
@extern("nk_window_get_panel");

fn Rect window_get_content_region(
  Context* ctx)
@extern("nk_window_get_content_region");

fn Vec2 window_get_content_region_min(
  Context* ctx)
@extern("nk_window_get_content_region_min");

fn Vec2 window_get_content_region_max(
  Context* ctx)
@extern("nk_window_get_content_region_max");

fn Vec2 window_get_content_region_size(
  Context* ctx)
@extern("nk_window_get_content_region_size");

fn CommandBuffer* window_get_canvas(
  Context* ctx)
@extern("nk_window_get_canvas");

fn void window_get_scroll(
  Context* ctx, 
  Uint* offset_x, 
  Uint* offset_y)
@extern("nk_window_get_scroll");

fn Bool window_has_focus(
  Context* ctx)
@extern("nk_window_has_focus");

fn Bool window_is_hovered(
  Context* ctx)
@extern("nk_window_is_hovered");

fn Bool window_is_collapsed(
  Context* ctx, 
  CChar* name)
@extern("nk_window_is_collapsed");

fn Bool window_is_closed(
  Context* ctx, 
  CChar* name)
@extern("nk_window_is_closed");

fn Bool window_is_hidden(
  Context* ctx, 
  CChar* name)
@extern("nk_window_is_hidden");

fn Bool window_is_active(
  Context* ctx, 
  CChar* name)
@extern("nk_window_is_active");

fn Bool window_is_any_hovered(
  Context* ctx)
@extern("nk_window_is_any_hovered");

fn Bool item_is_any_active(
  Context* ctx)
@extern("nk_item_is_any_active");

fn void window_set_bounds(
  Context* ctx, 
  CChar* name, 
  Rect bounds)
@extern("nk_window_set_bounds");

fn void window_set_position(
  Context* ctx, 
  CChar* name, 
  Vec2 pos)
@extern("nk_window_set_position");

fn void window_set_size(
  Context* ctx, 
  CChar* name, 
  Vec2 size)
@extern("nk_window_set_size");

fn void window_set_focus(
  Context* ctx, 
  CChar* name)
@extern("nk_window_set_focus");

fn void window_set_scroll(
  Context* ctx, 
  Uint offset_x, 
  Uint offset_y)
@extern("nk_window_set_scroll");

fn void window_close(
  Context* ctx, 
  CChar* name)
@extern("nk_window_close");

fn void window_collapse(
  Context* ctx, 
  CChar* name, 
  CollapseStates state)
@extern("nk_window_collapse");

fn void window_collapse_if(
  Context* ctx, 
  CChar* name, 
  CollapseStates state, 
  CInt cond)
@extern("nk_window_collapse_if");

fn void window_show(
  Context* ctx, 
  CChar* name, 
  ShowStates state)
@extern("nk_window_show");

fn void window_show_if(
  Context* ctx, 
  CChar* name, 
  ShowStates state, 
  CInt cond)
@extern("nk_window_show_if");

fn void rule_horizontal(
  Context* ctx, 
  Color color, 
  Bool rounding)
@extern("nk_rule_horizontal");

typedef WidgetAlign = inline CUInt;
const WidgetAlign WIDGET_ALIGN_LEFT = 0x01;
const WidgetAlign WIDGET_ALIGN_CENTERED = 0x02;
const WidgetAlign WIDGET_ALIGN_RIGHT = 0x04;
const WidgetAlign WIDGET_ALIGN_TOP = 0x08;
const WidgetAlign WIDGET_ALIGN_MIDDLE = 0x10;
const WidgetAlign WIDGET_ALIGN_BOTTOM = 0x20;

typedef WidgetAlignment = inline CUInt;
const WidgetAlignment WIDGET_LEFT = WIDGET_ALIGN_MIDDLE|WIDGET_ALIGN_LEFT;
const WidgetAlignment WIDGET_CENTERED = WIDGET_ALIGN_MIDDLE|WIDGET_ALIGN_CENTERED;
const WidgetAlignment WIDGET_RIGHT = WIDGET_ALIGN_MIDDLE|WIDGET_ALIGN_RIGHT;

fn void layout_set_min_row_height(
  Context*, 
  float height)
@extern("nk_layout_set_min_row_height");

fn void layout_reset_min_row_height(
  Context*)
@extern("nk_layout_reset_min_row_height");

fn Rect layout_widget_bounds(
  Context* ctx)
@extern("nk_layout_widget_bounds");

fn float layout_ratio_from_pixel(
  Context* ctx, 
  float pixel_width)
@extern("nk_layout_ratio_from_pixel");

fn void layout_row_dynamic(
  Context* ctx, 
  float height, 
  CInt cols)
@extern("nk_layout_row_dynamic");

fn void layout_row_static(
  Context* ctx, 
  float height, 
  CInt item_width, 
  CInt cols)
@extern("nk_layout_row_static");

fn void layout_row_begin(
  Context* ctx, 
  LayoutFormat fmt, 
  float row_height, 
  CInt cols)
@extern("nk_layout_row_begin");

fn void layout_row_push(
  Context*, 
  float value)
@extern("nk_layout_row_push");

fn void layout_row_end(
  Context*)
@extern("nk_layout_row_end");

fn void layout_row(
  Context*, 
  LayoutFormat, 
  float height, 
  CInt cols, 
  float* ratio)
@extern("nk_layout_row");

fn void layout_row_template_begin(
  Context*, 
  float row_height)
@extern("nk_layout_row_template_begin");

fn void layout_row_template_push_dynamic(
  Context*)
@extern("nk_layout_row_template_push_dynamic");

fn void layout_row_template_push_variable(
  Context*, 
  float min_width)
@extern("nk_layout_row_template_push_variable");

fn void layout_row_template_push_static(
  Context*, 
  float width)
@extern("nk_layout_row_template_push_static");

fn void layout_row_template_end(
  Context*)
@extern("nk_layout_row_template_end");

fn void layout_space_begin(
  Context*, 
  LayoutFormat, 
  float height, 
  CInt widget_count)
@extern("nk_layout_space_begin");

fn void layout_space_push(
  Context*, 
  Rect bounds)
@extern("nk_layout_space_push");

fn void layout_space_end(
  Context*)
@extern("nk_layout_space_end");

fn Rect layout_space_bounds(
  Context* ctx)
@extern("nk_layout_space_bounds");

fn Vec2 layout_space_to_screen(
  Context* ctx, 
  Vec2 vec)
@extern("nk_layout_space_to_screen");

fn Vec2 layout_space_to_local(
  Context* ctx, 
  Vec2 vec)
@extern("nk_layout_space_to_local");

fn Rect layout_space_rect_to_screen(
  Context* ctx, 
  Rect bounds)
@extern("nk_layout_space_rect_to_screen");

fn Rect layout_space_rect_to_local(
  Context* ctx, 
  Rect bounds)
@extern("nk_layout_space_rect_to_local");

fn void spacer(
  Context* ctx)
@extern("nk_spacer");

fn Bool group_begin(
  Context*, 
  CChar* title, 
  Flags)
@extern("nk_group_begin");

fn Bool group_begin_titled(
  Context*, 
  CChar* name, 
  CChar* title, 
  Flags)
@extern("nk_group_begin_titled");

fn void group_end(
  Context*)
@extern("nk_group_end");

fn Bool group_scrolled_offset_begin(
  Context*, 
  Uint* x_offset, 
  Uint* y_offset, 
  CChar* title, 
  Flags flags)
@extern("nk_group_scrolled_offset_begin");

fn Bool group_scrolled_begin(
  Context*, 
  Scroll* off, 
  CChar* title, 
  Flags)
@extern("nk_group_scrolled_begin");

fn void group_scrolled_end(
  Context*)
@extern("nk_group_scrolled_end");

fn void group_get_scroll(
  Context*, 
  CChar* id, 
  Uint* x_offset, 
  Uint* y_offset)
@extern("nk_group_get_scroll");

fn void group_set_scroll(
  Context*, 
  CChar* id, 
  Uint x_offset, 
  Uint y_offset)
@extern("nk_group_set_scroll");

fn Bool tree_push_hashed(
  Context*, 
  TreeType, 
  CChar* title, 
  CollapseStates initial_state, 
  CChar* hash, 
  CInt len, 
  CInt seed)
@extern("nk_tree_push_hashed");

fn Bool tree_image_push_hashed(
  Context*, 
  TreeType, 
  Image, 
  CChar* title, 
  CollapseStates initial_state, 
  CChar* hash, 
  CInt len, 
  CInt seed)
@extern("nk_tree_image_push_hashed");

fn void tree_pop(
  Context*)
@extern("nk_tree_pop");

fn Bool tree_state_push(
  Context*, 
  TreeType, 
  CChar* title, 
  CollapseStates* state)
@extern("nk_tree_state_push");

fn Bool tree_state_image_push(
  Context*, 
  TreeType, 
  Image, 
  CChar* title, 
  CollapseStates* state)
@extern("nk_tree_state_image_push");

fn void tree_state_pop(
  Context*)
@extern("nk_tree_state_pop");

fn Bool tree_element_push_hashed(
  Context*, 
  TreeType, 
  CChar* title, 
  CollapseStates initial_state, 
  Bool* selected, 
  CChar* hash, 
  CInt len, 
  CInt seed)
@extern("nk_tree_element_push_hashed");

fn Bool tree_element_image_push_hashed(
  Context*, 
  TreeType, 
  Image, 
  CChar* title, 
  CollapseStates initial_state, 
  Bool* selected, 
  CChar* hash, 
  CInt len, 
  CInt seed)
@extern("nk_tree_element_image_push_hashed");

fn void tree_element_pop(
  Context*)
@extern("nk_tree_element_pop");

struct ListView {
  CInt begin;
  CInt end;
  CInt count;
  CInt total_height;
  Context* ctx;
  Uint* scroll_pointer;
  Uint scroll_value;
}

fn Bool list_view_begin(
  Context*, 
  ListView* out, 
  CChar* id, 
  Flags, 
  CInt row_height, 
  CInt row_count)
@extern("nk_list_view_begin");

fn void list_view_end(
  ListView*)
@extern("nk_list_view_end");

typedef WidgetLayoutStates = inline CUInt;
const WidgetLayoutStates WIDGET_INVALID = 0;
const WidgetLayoutStates WIDGET_VALID = 1;
const WidgetLayoutStates WIDGET_ROM = 2;
const WidgetLayoutStates WIDGET_DISABLED = 3;

typedef WidgetStates = inline CUInt;
const WidgetStates WIDGET_STATE_MODIFIED = @flag(1);
const WidgetStates WIDGET_STATE_INACTIVE = @flag(2);
const WidgetStates WIDGET_STATE_ENTERED = @flag(3);
const WidgetStates WIDGET_STATE_HOVER = @flag(4);
const WidgetStates WIDGET_STATE_ACTIVED = @flag(5);
const WidgetStates WIDGET_STATE_LEFT = @flag(6);
const WidgetStates WIDGET_STATE_HOVERED = WIDGET_STATE_HOVER|WIDGET_STATE_MODIFIED;
const WidgetStates WIDGET_STATE_ACTIVE = WIDGET_STATE_ACTIVED|WIDGET_STATE_MODIFIED;

fn WidgetLayoutStates widget(
  Rect*, 
  Context*)
@extern("nk_widget");

fn WidgetLayoutStates widget_fitting(
  Rect*, 
  Context*, 
  Vec2)
@extern("nk_widget_fitting");

fn Rect widget_bounds(
  Context*)
@extern("nk_widget_bounds");

fn Vec2 widget_position(
  Context*)
@extern("nk_widget_position");

fn Vec2 widget_size(
  Context*)
@extern("nk_widget_size");

fn float widget_width(
  Context*)
@extern("nk_widget_width");

fn float widget_height(
  Context*)
@extern("nk_widget_height");

fn Bool widget_is_hovered(
  Context*)
@extern("nk_widget_is_hovered");

fn Bool widget_is_mouse_clicked(
  Context*, 
  Buttons)
@extern("nk_widget_is_mouse_clicked");

fn Bool widget_has_mouse_click_down(
  Context*, 
  Buttons, 
  Bool down)
@extern("nk_widget_has_mouse_click_down");

fn void spacing(
  Context*, 
  CInt cols)
@extern("nk_spacing");

fn void widget_disable_begin(
  Context* ctx)
@extern("nk_widget_disable_begin");

fn void widget_disable_end(
  Context* ctx)
@extern("nk_widget_disable_end");

typedef TextAlign = inline CUInt;
const TextAlign TEXT_ALIGN_LEFT = 0x01;
const TextAlign TEXT_ALIGN_CENTERED = 0x02;
const TextAlign TEXT_ALIGN_RIGHT = 0x04;
const TextAlign TEXT_ALIGN_TOP = 0x08;
const TextAlign TEXT_ALIGN_MIDDLE = 0x10;
const TextAlign TEXT_ALIGN_BOTTOM = 0x20;

typedef TextAlignment = inline CUInt;
const TextAlignment TEXT_LEFT = TEXT_ALIGN_MIDDLE|TEXT_ALIGN_LEFT;
const TextAlignment TEXT_CENTERED = TEXT_ALIGN_MIDDLE|TEXT_ALIGN_CENTERED;
const TextAlignment TEXT_RIGHT = TEXT_ALIGN_MIDDLE|TEXT_ALIGN_RIGHT;

fn void text(
  Context*, 
  CChar*, 
  CInt, 
  Flags)
@extern("nk_text");

fn void text_colored(
  Context*, 
  CChar*, 
  CInt, 
  Flags, 
  Color)
@extern("nk_text_colored");

fn void text_wrap(
  Context*, 
  CChar*, 
  CInt)
@extern("nk_text_wrap");

fn void text_wrap_colored(
  Context*, 
  CChar*, 
  CInt, 
  Color)
@extern("nk_text_wrap_colored");

fn void label(
  Context*, 
  CChar*, 
  Flags align)
@extern("nk_label");

fn void label_colored(
  Context*, 
  CChar*, 
  Flags align, 
  Color)
@extern("nk_label_colored");

fn void label_wrap(
  Context*, 
  CChar*)
@extern("nk_label_wrap");

fn void label_colored_wrap(
  Context*, 
  CChar*, 
  Color)
@extern("nk_label_colored_wrap");

fn void image(
  Context*, 
  Image)
@extern("nk_image");

fn void image_color(
  Context*, 
  Image, 
  Color)
@extern("nk_image_color");

fn void labelf(
  Context*, 
  Flags, 
  CChar*)
@extern("nk_labelf");

fn void labelf_colored(
  Context*, 
  Flags, 
  Color, 
  CChar*)
@extern("nk_labelf_colored");

fn void labelf_wrap(
  Context*, 
  CChar*)
@extern("nk_labelf_wrap");

fn void labelf_colored_wrap(
  Context*, 
  Color, 
  CChar*)
@extern("nk_labelf_colored_wrap");

fn void labelfv(
  Context*, 
  Flags, 
  CChar*, 
  void*)
@extern("nk_labelfv");

fn void labelfv_colored(
  Context*, 
  Flags, 
  Color, 
  CChar*, 
  void*)
@extern("nk_labelfv_colored");

fn void labelfv_wrap(
  Context*, 
  CChar*, 
  void*)
@extern("nk_labelfv_wrap");

fn void labelfv_colored_wrap(
  Context*, 
  Color, 
  CChar*, 
  void*)
@extern("nk_labelfv_colored_wrap");

fn void value_bool(
  Context*, 
  CChar* prefix, 
  CInt)
@extern("nk_value_bool");

fn void value_int(
  Context*, 
  CChar* prefix, 
  CInt)
@extern("nk_value_int");

fn void value_uint(
  Context*, 
  CChar* prefix, 
  CUInt)
@extern("nk_value_uint");

fn void value_float(
  Context*, 
  CChar* prefix, 
  float)
@extern("nk_value_float");

fn void value_color_byte(
  Context*, 
  CChar* prefix, 
  Color)
@extern("nk_value_color_byte");

fn void value_color_float(
  Context*, 
  CChar* prefix, 
  Color)
@extern("nk_value_color_float");

fn void value_color_hex(
  Context*, 
  CChar* prefix, 
  Color)
@extern("nk_value_color_hex");

fn Bool button_text(
  Context*, 
  CChar* title, 
  CInt len)
@extern("nk_button_text");

fn Bool button_label(
  Context*, 
  CChar* title)
@extern("nk_button_label");

fn Bool button_color(
  Context*, 
  Color)
@extern("nk_button_color");

fn Bool button_symbol(
  Context*, 
  SymbolType)
@extern("nk_button_symbol");

fn Bool button_image(
  Context*, 
  Image img)
@extern("nk_button_image");

fn Bool button_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags text_alignment)
@extern("nk_button_symbol_label");

fn Bool button_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_button_symbol_text");

fn Bool button_image_label(
  Context*, 
  Image img, 
  CChar*, 
  Flags text_alignment)
@extern("nk_button_image_label");

fn Bool button_image_text(
  Context*, 
  Image img, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_button_image_text");

fn Bool button_text_styled(
  Context*, 
  StyleButton*, 
  CChar* title, 
  CInt len)
@extern("nk_button_text_styled");

fn Bool button_label_styled(
  Context*, 
  StyleButton*, 
  CChar* title)
@extern("nk_button_label_styled");

fn Bool button_symbol_styled(
  Context*, 
  StyleButton*, 
  SymbolType)
@extern("nk_button_symbol_styled");

fn Bool button_image_styled(
  Context*, 
  StyleButton*, 
  Image img)
@extern("nk_button_image_styled");

fn Bool button_symbol_text_styled(
  Context*, 
  StyleButton*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_button_symbol_text_styled");

fn Bool button_symbol_label_styled(
  Context* ctx, 
  StyleButton* style, 
  SymbolType symbol, 
  CChar* title, 
  Flags align)
@extern("nk_button_symbol_label_styled");

fn Bool button_image_label_styled(
  Context*, 
  StyleButton*, 
  Image img, 
  CChar*, 
  Flags text_alignment)
@extern("nk_button_image_label_styled");

fn Bool button_image_text_styled(
  Context*, 
  StyleButton*, 
  Image img, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_button_image_text_styled");

fn void button_set_behavior(
  Context*, 
  ButtonBehavior)
@extern("nk_button_set_behavior");

fn Bool button_push_behavior(
  Context*, 
  ButtonBehavior)
@extern("nk_button_push_behavior");

fn Bool button_pop_behavior(
  Context*)
@extern("nk_button_pop_behavior");

fn Bool check_label(
  Context*, 
  CChar*, 
  Bool active)
@extern("nk_check_label");

fn Bool check_text(
  Context*, 
  CChar*, 
  CInt, 
  Bool active)
@extern("nk_check_text");

fn Bool check_text_align(
  Context*, 
  CChar*, 
  CInt, 
  Bool active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_check_text_align");

fn CUInt check_flags_label(
  Context*, 
  CChar*, 
  CUInt flags, 
  CUInt value)
@extern("nk_check_flags_label");

fn CUInt check_flags_text(
  Context*, 
  CChar*, 
  CInt, 
  CUInt flags, 
  CUInt value)
@extern("nk_check_flags_text");

fn Bool checkbox_label(
  Context*, 
  CChar*, 
  Bool* active)
@extern("nk_checkbox_label");

fn Bool checkbox_label_align(
  Context* ctx, 
  CChar* label, 
  Bool* active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_checkbox_label_align");

fn Bool checkbox_text(
  Context*, 
  CChar*, 
  CInt, 
  Bool* active)
@extern("nk_checkbox_text");

fn Bool checkbox_text_align(
  Context* ctx, 
  CChar* text, 
  CInt len, 
  Bool* active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_checkbox_text_align");

fn Bool checkbox_flags_label(
  Context*, 
  CChar*, 
  CUInt* flags, 
  CUInt value)
@extern("nk_checkbox_flags_label");

fn Bool checkbox_flags_text(
  Context*, 
  CChar*, 
  CInt, 
  CUInt* flags, 
  CUInt value)
@extern("nk_checkbox_flags_text");

fn Bool radio_label(
  Context*, 
  CChar*, 
  Bool* active)
@extern("nk_radio_label");

fn Bool radio_label_align(
  Context* ctx, 
  CChar* label, 
  Bool* active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_radio_label_align");

fn Bool radio_text(
  Context*, 
  CChar*, 
  CInt, 
  Bool* active)
@extern("nk_radio_text");

fn Bool radio_text_align(
  Context* ctx, 
  CChar* text, 
  CInt len, 
  Bool* active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_radio_text_align");

fn Bool option_label(
  Context*, 
  CChar*, 
  Bool active)
@extern("nk_option_label");

fn Bool option_label_align(
  Context* ctx, 
  CChar* label, 
  Bool active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_option_label_align");

fn Bool option_text(
  Context*, 
  CChar*, 
  CInt, 
  Bool active)
@extern("nk_option_text");

fn Bool option_text_align(
  Context* ctx, 
  CChar* text, 
  CInt len, 
  Bool is_active, 
  Flags widget_alignment, 
  Flags text_alignment)
@extern("nk_option_text_align");

fn Bool selectable_label(
  Context*, 
  CChar*, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_label");

fn Bool selectable_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_text");

fn Bool selectable_image_label(
  Context*, 
  Image, 
  CChar*, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_image_label");

fn Bool selectable_image_text(
  Context*, 
  Image, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_image_text");

fn Bool selectable_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_symbol_label");

fn Bool selectable_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool* value)
@extern("nk_selectable_symbol_text");

fn Bool select_label(
  Context*, 
  CChar*, 
  Flags align, 
  Bool value)
@extern("nk_select_label");

fn Bool select_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool value)
@extern("nk_select_text");

fn Bool select_image_label(
  Context*, 
  Image, 
  CChar*, 
  Flags align, 
  Bool value)
@extern("nk_select_image_label");

fn Bool select_image_text(
  Context*, 
  Image, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool value)
@extern("nk_select_image_text");

fn Bool select_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags align, 
  Bool value)
@extern("nk_select_symbol_label");

fn Bool select_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags align, 
  Bool value)
@extern("nk_select_symbol_text");

fn float slide_float(
  Context*, 
  float min, 
  float val, 
  float max, 
  float step)
@extern("nk_slide_float");

fn CInt slide_int(
  Context*, 
  CInt min, 
  CInt val, 
  CInt max, 
  CInt step)
@extern("nk_slide_int");

fn Bool slider_float(
  Context*, 
  float min, 
  float* val, 
  float max, 
  float step)
@extern("nk_slider_float");

fn Bool slider_int(
  Context*, 
  CInt min, 
  CInt* val, 
  CInt max, 
  CInt step)
@extern("nk_slider_int");

fn Bool knob_float(
  Context*, 
  float min, 
  float* val, 
  float max, 
  float step, 
  Heading zero_direction, 
  float dead_zone_degrees)
@extern("nk_knob_float");

fn Bool knob_int(
  Context*, 
  CInt min, 
  CInt* val, 
  CInt max, 
  CInt step, 
  Heading zero_direction, 
  float dead_zone_degrees)
@extern("nk_knob_int");

fn Bool progress(
  Context*, 
  Size* cur, 
  Size max, 
  Bool modifyable)
@extern("nk_progress");

fn Size prog(
  Context*, 
  Size cur, 
  Size max, 
  Bool modifyable)
@extern("nk_prog");

fn Colorf color_picker(
  Context*, 
  Colorf, 
  ColorFormat)
@extern("nk_color_picker");

fn Bool color_pick(
  Context*, 
  Colorf*, 
  ColorFormat)
@extern("nk_color_pick");

fn void property_int(
  Context*, 
  CChar* name, 
  CInt min, 
  CInt* val, 
  CInt max, 
  CInt step, 
  float inc_per_pixel)
@extern("nk_property_int");

fn void property_float(
  Context*, 
  CChar* name, 
  float min, 
  float* val, 
  float max, 
  float step, 
  float inc_per_pixel)
@extern("nk_property_float");

fn void property_double(
  Context*, 
  CChar* name, 
  double min, 
  double* val, 
  double max, 
  double step, 
  float inc_per_pixel)
@extern("nk_property_double");

fn CInt propertyi(
  Context*, 
  CChar* name, 
  CInt min, 
  CInt val, 
  CInt max, 
  CInt step, 
  float inc_per_pixel)
@extern("nk_propertyi");

fn float propertyf(
  Context*, 
  CChar* name, 
  float min, 
  float val, 
  float max, 
  float step, 
  float inc_per_pixel)
@extern("nk_propertyf");

fn double propertyd(
  Context*, 
  CChar* name, 
  double min, 
  double val, 
  double max, 
  double step, 
  float inc_per_pixel)
@extern("nk_propertyd");

typedef EditFlags = inline CUInt;
const EditFlags EDIT_DEFAULT = 0;
const EditFlags EDIT_READ_ONLY = @flag(0);
const EditFlags EDIT_AUTO_SELECT = @flag(1);
const EditFlags EDIT_SIG_ENTER = @flag(2);
const EditFlags EDIT_ALLOW_TAB = @flag(3);
const EditFlags EDIT_NO_CURSOR = @flag(4);
const EditFlags EDIT_SELECTABLE = @flag(5);
const EditFlags EDIT_CLIPBOARD = @flag(6);
const EditFlags EDIT_CTRL_ENTER_NEWLINE = @flag(7);
const EditFlags EDIT_NO_HORIZONTAL_SCROLL = @flag(8);
const EditFlags EDIT_ALWAYS_INSERT_MODE = @flag(9);
const EditFlags EDIT_MULTILINE = @flag(10);
const EditFlags EDIT_GOTO_END_ON_ACTIVATE = @flag(11);

typedef EditTypes = inline CUInt;
const EditTypes EDIT_SIMPLE = EDIT_ALWAYS_INSERT_MODE;
const EditTypes EDIT_FIELD = EDIT_SIMPLE|EDIT_SELECTABLE|EDIT_CLIPBOARD;
const EditTypes EDIT_BOX = EDIT_ALWAYS_INSERT_MODE|EDIT_SELECTABLE|EDIT_MULTILINE|EDIT_ALLOW_TAB|EDIT_CLIPBOARD;
const EditTypes EDIT_EDITOR = EDIT_SELECTABLE|EDIT_MULTILINE|EDIT_ALLOW_TAB|EDIT_CLIPBOARD;

typedef EditEvents = inline CUInt;
const EditEvents EDIT_ACTIVE = @flag(0);
const EditEvents EDIT_INACTIVE = @flag(1);
const EditEvents EDIT_ACTIVATED = @flag(2);
const EditEvents EDIT_DEACTIVATED = @flag(3);
const EditEvents EDIT_COMMITED = @flag(4);

fn Flags edit_string(
  Context*, 
  Flags, 
  CChar* buffer, 
  CInt* len, 
  CInt max, 
  PluginFilter)
@extern("nk_edit_string");

fn Flags edit_string_zero_terminated(
  Context*, 
  Flags, 
  CChar* buffer, 
  CInt max, 
  PluginFilter)
@extern("nk_edit_string_zero_terminated");

fn Flags edit_buffer(
  Context*, 
  Flags, 
  TextEdit*, 
  PluginFilter)
@extern("nk_edit_buffer");

fn void edit_focus(
  Context*, 
  Flags flags)
@extern("nk_edit_focus");

fn void edit_unfocus(
  Context*)
@extern("nk_edit_unfocus");

fn Bool chart_begin(
  Context*, 
  ChartType, 
  CInt num, 
  float min, 
  float max)
@extern("nk_chart_begin");

fn Bool chart_begin_colored(
  Context*, 
  ChartType, 
  Color, 
  Color active, 
  CInt num, 
  float min, 
  float max)
@extern("nk_chart_begin_colored");

fn void chart_add_slot(
  Context* ctx, 
  ChartType, 
  CInt count, 
  float min_value, 
  float max_value)
@extern("nk_chart_add_slot");

fn void chart_add_slot_colored(
  Context* ctx, 
  ChartType, 
  Color, 
  Color active, 
  CInt count, 
  float min_value, 
  float max_value)
@extern("nk_chart_add_slot_colored");

fn Flags chart_push(
  Context*, 
  float)
@extern("nk_chart_push");

fn Flags chart_push_slot(
  Context*, 
  float, 
  CInt)
@extern("nk_chart_push_slot");

fn void chart_end(
  Context*)
@extern("nk_chart_end");

fn void plot(
  Context*, 
  ChartType, 
  float* values, 
  CInt count, 
  CInt offset)
@extern("nk_plot");

alias UnnamedPFN1 @private = fn float(
  void* user, 
  CInt index);

fn void plot_function(
  Context*, 
  ChartType, 
  void* userdata, 
  UnnamedPFN1 value_getter, 
  CInt count, 
  CInt offset)
@extern("nk_plot_function");

fn Bool popup_begin(
  Context*, 
  PopupType, 
  CChar*, 
  Flags, 
  Rect bounds)
@extern("nk_popup_begin");

fn void popup_close(
  Context*)
@extern("nk_popup_close");

fn void popup_end(
  Context*)
@extern("nk_popup_end");

fn void popup_get_scroll(
  Context*, 
  Uint* offset_x, 
  Uint* offset_y)
@extern("nk_popup_get_scroll");

fn void popup_set_scroll(
  Context*, 
  Uint offset_x, 
  Uint offset_y)
@extern("nk_popup_set_scroll");

fn CInt combo(
  Context*, 
  CChar** items, 
  CInt count, 
  CInt selected, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combo");

fn CInt combo_separator(
  Context*, 
  CChar* items_separated_by_separator, 
  CInt separator, 
  CInt selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combo_separator");

fn CInt combo_string(
  Context*, 
  CChar* items_separated_by_zeros, 
  CInt selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combo_string");

alias UnnamedPFN2 @private = fn void(
  void*, 
  CInt, 
  CChar**);

fn CInt combo_callback(
  Context*, 
  UnnamedPFN2 item_getter, 
  void* userdata, 
  CInt selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combo_callback");

fn void combobox(
  Context*, 
  CChar** items, 
  CInt count, 
  CInt* selected, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combobox");

fn void combobox_string(
  Context*, 
  CChar* items_separated_by_zeros, 
  CInt* selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combobox_string");

fn void combobox_separator(
  Context*, 
  CChar* items_separated_by_separator, 
  CInt separator, 
  CInt* selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combobox_separator");

fn void combobox_callback(
  Context*, 
  UnnamedPFN2 item_getter, 
  void*, 
  CInt* selected, 
  CInt count, 
  CInt item_height, 
  Vec2 size)
@extern("nk_combobox_callback");

fn Bool combo_begin_text(
  Context*, 
  CChar* selected, 
  CInt, 
  Vec2 size)
@extern("nk_combo_begin_text");

fn Bool combo_begin_label(
  Context*, 
  CChar* selected, 
  Vec2 size)
@extern("nk_combo_begin_label");

fn Bool combo_begin_color(
  Context*, 
  Color color, 
  Vec2 size)
@extern("nk_combo_begin_color");

fn Bool combo_begin_symbol(
  Context*, 
  SymbolType, 
  Vec2 size)
@extern("nk_combo_begin_symbol");

fn Bool combo_begin_symbol_label(
  Context*, 
  CChar* selected, 
  SymbolType, 
  Vec2 size)
@extern("nk_combo_begin_symbol_label");

fn Bool combo_begin_symbol_text(
  Context*, 
  CChar* selected, 
  CInt, 
  SymbolType, 
  Vec2 size)
@extern("nk_combo_begin_symbol_text");

fn Bool combo_begin_image(
  Context*, 
  Image img, 
  Vec2 size)
@extern("nk_combo_begin_image");

fn Bool combo_begin_image_label(
  Context*, 
  CChar* selected, 
  Image, 
  Vec2 size)
@extern("nk_combo_begin_image_label");

fn Bool combo_begin_image_text(
  Context*, 
  CChar* selected, 
  CInt, 
  Image, 
  Vec2 size)
@extern("nk_combo_begin_image_text");

fn Bool combo_item_label(
  Context*, 
  CChar*, 
  Flags alignment)
@extern("nk_combo_item_label");

fn Bool combo_item_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_combo_item_text");

fn Bool combo_item_image_label(
  Context*, 
  Image, 
  CChar*, 
  Flags alignment)
@extern("nk_combo_item_image_label");

fn Bool combo_item_image_text(
  Context*, 
  Image, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_combo_item_image_text");

fn Bool combo_item_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags alignment)
@extern("nk_combo_item_symbol_label");

fn Bool combo_item_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_combo_item_symbol_text");

fn void combo_close(
  Context*)
@extern("nk_combo_close");

fn void combo_end(
  Context*)
@extern("nk_combo_end");

fn Bool contextual_begin(
  Context*, 
  Flags, 
  Vec2, 
  Rect trigger_bounds)
@extern("nk_contextual_begin");

fn Bool contextual_item_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align)
@extern("nk_contextual_item_text");

fn Bool contextual_item_label(
  Context*, 
  CChar*, 
  Flags align)
@extern("nk_contextual_item_label");

fn Bool contextual_item_image_label(
  Context*, 
  Image, 
  CChar*, 
  Flags alignment)
@extern("nk_contextual_item_image_label");

fn Bool contextual_item_image_text(
  Context*, 
  Image, 
  CChar*, 
  CInt len, 
  Flags alignment)
@extern("nk_contextual_item_image_text");

fn Bool contextual_item_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags alignment)
@extern("nk_contextual_item_symbol_label");

fn Bool contextual_item_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_contextual_item_symbol_text");

fn void contextual_close(
  Context*)
@extern("nk_contextual_close");

fn void contextual_end(
  Context*)
@extern("nk_contextual_end");

fn void tooltip(
  Context*, 
  CChar*)
@extern("nk_tooltip");

fn void tooltipf(
  Context*, 
  CChar*)
@extern("nk_tooltipf");

fn void tooltipfv(
  Context*, 
  CChar*, 
  void*)
@extern("nk_tooltipfv");

fn Bool tooltip_begin(
  Context*, 
  float width)
@extern("nk_tooltip_begin");

fn void tooltip_end(
  Context*)
@extern("nk_tooltip_end");

fn void menubar_begin(
  Context*)
@extern("nk_menubar_begin");

fn void menubar_end(
  Context*)
@extern("nk_menubar_end");

fn Bool menu_begin_text(
  Context*, 
  CChar* title, 
  CInt title_len, 
  Flags align, 
  Vec2 size)
@extern("nk_menu_begin_text");

fn Bool menu_begin_label(
  Context*, 
  CChar*, 
  Flags align, 
  Vec2 size)
@extern("nk_menu_begin_label");

fn Bool menu_begin_image(
  Context*, 
  CChar*, 
  Image, 
  Vec2 size)
@extern("nk_menu_begin_image");

fn Bool menu_begin_image_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align, 
  Image, 
  Vec2 size)
@extern("nk_menu_begin_image_text");

fn Bool menu_begin_image_label(
  Context*, 
  CChar*, 
  Flags align, 
  Image, 
  Vec2 size)
@extern("nk_menu_begin_image_label");

fn Bool menu_begin_symbol(
  Context*, 
  CChar*, 
  SymbolType, 
  Vec2 size)
@extern("nk_menu_begin_symbol");

fn Bool menu_begin_symbol_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align, 
  SymbolType, 
  Vec2 size)
@extern("nk_menu_begin_symbol_text");

fn Bool menu_begin_symbol_label(
  Context*, 
  CChar*, 
  Flags align, 
  SymbolType, 
  Vec2 size)
@extern("nk_menu_begin_symbol_label");

fn Bool menu_item_text(
  Context*, 
  CChar*, 
  CInt, 
  Flags align)
@extern("nk_menu_item_text");

fn Bool menu_item_label(
  Context*, 
  CChar*, 
  Flags alignment)
@extern("nk_menu_item_label");

fn Bool menu_item_image_label(
  Context*, 
  Image, 
  CChar*, 
  Flags alignment)
@extern("nk_menu_item_image_label");

fn Bool menu_item_image_text(
  Context*, 
  Image, 
  CChar*, 
  CInt len, 
  Flags alignment)
@extern("nk_menu_item_image_text");

fn Bool menu_item_symbol_text(
  Context*, 
  SymbolType, 
  CChar*, 
  CInt, 
  Flags alignment)
@extern("nk_menu_item_symbol_text");

fn Bool menu_item_symbol_label(
  Context*, 
  SymbolType, 
  CChar*, 
  Flags alignment)
@extern("nk_menu_item_symbol_label");

fn void menu_close(
  Context*)
@extern("nk_menu_close");

fn void menu_end(
  Context*)
@extern("nk_menu_end");

typedef StyleColors = inline CUInt;
const StyleColors COLOR_TEXT = 0;
const StyleColors COLOR_WINDOW = 1;
const StyleColors COLOR_HEADER = 2;
const StyleColors COLOR_BORDER = 3;
const StyleColors COLOR_BUTTON = 4;
const StyleColors COLOR_BUTTON_HOVER = 5;
const StyleColors COLOR_BUTTON_ACTIVE = 6;
const StyleColors COLOR_TOGGLE = 7;
const StyleColors COLOR_TOGGLE_HOVER = 8;
const StyleColors COLOR_TOGGLE_CURSOR = 9;
const StyleColors COLOR_SELECT = 10;
const StyleColors COLOR_SELECT_ACTIVE = 11;
const StyleColors COLOR_SLIDER = 12;
const StyleColors COLOR_SLIDER_CURSOR = 13;
const StyleColors COLOR_SLIDER_CURSOR_HOVER = 14;
const StyleColors COLOR_SLIDER_CURSOR_ACTIVE = 15;
const StyleColors COLOR_PROPERTY = 16;
const StyleColors COLOR_EDIT = 17;
const StyleColors COLOR_EDIT_CURSOR = 18;
const StyleColors COLOR_COMBO = 19;
const StyleColors COLOR_CHART = 20;
const StyleColors COLOR_CHART_COLOR = 21;
const StyleColors COLOR_CHART_COLOR_HIGHLIGHT = 22;
const StyleColors COLOR_SCROLLBAR = 23;
const StyleColors COLOR_SCROLLBAR_CURSOR = 24;
const StyleColors COLOR_SCROLLBAR_CURSOR_HOVER = 25;
const StyleColors COLOR_SCROLLBAR_CURSOR_ACTIVE = 26;
const StyleColors COLOR_TAB_HEADER = 27;
const StyleColors COLOR_KNOB = 28;
const StyleColors COLOR_KNOB_CURSOR = 29;
const StyleColors COLOR_KNOB_CURSOR_HOVER = 30;
const StyleColors COLOR_KNOB_CURSOR_ACTIVE = 31;
const StyleColors COLOR_COUNT = 32;

typedef StyleCursor = inline CUInt;
const StyleCursor CURSOR_ARROW = 0;
const StyleCursor CURSOR_TEXT = 1;
const StyleCursor CURSOR_MOVE = 2;
const StyleCursor CURSOR_RESIZE_VERTICAL = 3;
const StyleCursor CURSOR_RESIZE_HORIZONTAL = 4;
const StyleCursor CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5;
const StyleCursor CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6;
const StyleCursor CURSOR_COUNT = 7;

fn void style_default(
  Context*)
@extern("nk_style_default");

fn void style_from_table(
  Context*, 
  Color*)
@extern("nk_style_from_table");

fn void style_load_cursor(
  Context*, 
  StyleCursor, 
  Cursor*)
@extern("nk_style_load_cursor");

fn void style_load_all_cursors(
  Context*, 
  Cursor*)
@extern("nk_style_load_all_cursors");

fn CChar* style_get_color_by_name(
  StyleColors)
@extern("nk_style_get_color_by_name");

fn void style_set_font(
  Context*, 
  UserFont*)
@extern("nk_style_set_font");

fn Bool style_set_cursor(
  Context*, 
  StyleCursor)
@extern("nk_style_set_cursor");

fn void style_show_cursor(
  Context*)
@extern("nk_style_show_cursor");

fn void style_hide_cursor(
  Context*)
@extern("nk_style_hide_cursor");

fn Bool style_push_font(
  Context*, 
  UserFont*)
@extern("nk_style_push_font");

fn Bool style_push_float(
  Context*, 
  float*, 
  float)
@extern("nk_style_push_float");

fn Bool style_push_vec2(
  Context*, 
  Vec2*, 
  Vec2)
@extern("nk_style_push_vec2");

fn Bool style_push_style_item(
  Context*, 
  StyleItem*, 
  StyleItem)
@extern("nk_style_push_style_item");

fn Bool style_push_flags(
  Context*, 
  Flags*, 
  Flags)
@extern("nk_style_push_flags");

fn Bool style_push_color(
  Context*, 
  Color*, 
  Color)
@extern("nk_style_push_color");

fn Bool style_pop_font(
  Context*)
@extern("nk_style_pop_font");

fn Bool style_pop_float(
  Context*)
@extern("nk_style_pop_float");

fn Bool style_pop_vec2(
  Context*)
@extern("nk_style_pop_vec2");

fn Bool style_pop_style_item(
  Context*)
@extern("nk_style_pop_style_item");

fn Bool style_pop_flags(
  Context*)
@extern("nk_style_pop_flags");

fn Bool style_pop_color(
  Context*)
@extern("nk_style_pop_color");

fn Color rgb(
  CInt r, 
  CInt g, 
  CInt b)
@extern("nk_rgb");

fn Color rgb_iv(
  CInt* rgb)
@extern("nk_rgb_iv");

fn Color rgb_bv(
  Byte* rgb)
@extern("nk_rgb_bv");

fn Color rgb_f(
  float r, 
  float g, 
  float b)
@extern("nk_rgb_f");

fn Color rgb_fv(
  float* rgb)
@extern("nk_rgb_fv");

fn Color rgb_cf(
  Colorf c)
@extern("nk_rgb_cf");

fn Color rgb_hex(
  CChar* rgb)
@extern("nk_rgb_hex");

fn Color rgb_factor(
  Color col, 
  float factor)
@extern("nk_rgb_factor");

fn Color rgba(
  CInt r, 
  CInt g, 
  CInt b, 
  CInt a)
@extern("nk_rgba");

fn Color rgba_u32(
  Uint)
@extern("nk_rgba_u32");

fn Color rgba_iv(
  CInt* rgba)
@extern("nk_rgba_iv");

fn Color rgba_bv(
  Byte* rgba)
@extern("nk_rgba_bv");

fn Color rgba_f(
  float r, 
  float g, 
  float b, 
  float a)
@extern("nk_rgba_f");

fn Color rgba_fv(
  float* rgba)
@extern("nk_rgba_fv");

fn Color rgba_cf(
  Colorf c)
@extern("nk_rgba_cf");

fn Color rgba_hex(
  CChar* rgb)
@extern("nk_rgba_hex");

fn Colorf hsva_colorf(
  float h, 
  float s, 
  float v, 
  float a)
@extern("nk_hsva_colorf");

fn Colorf hsva_colorfv(
  float* c)
@extern("nk_hsva_colorfv");

fn void colorf_hsva_f(
  float* out_h, 
  float* out_s, 
  float* out_v, 
  float* out_a, 
  Colorf in)
@extern("nk_colorf_hsva_f");

fn void colorf_hsva_fv(
  float* hsva, 
  Colorf in)
@extern("nk_colorf_hsva_fv");

fn Color hsv(
  CInt h, 
  CInt s, 
  CInt v)
@extern("nk_hsv");

fn Color hsv_iv(
  CInt* hsv)
@extern("nk_hsv_iv");

fn Color hsv_bv(
  Byte* hsv)
@extern("nk_hsv_bv");

fn Color hsv_f(
  float h, 
  float s, 
  float v)
@extern("nk_hsv_f");

fn Color hsv_fv(
  float* hsv)
@extern("nk_hsv_fv");

fn Color hsva(
  CInt h, 
  CInt s, 
  CInt v, 
  CInt a)
@extern("nk_hsva");

fn Color hsva_iv(
  CInt* hsva)
@extern("nk_hsva_iv");

fn Color hsva_bv(
  Byte* hsva)
@extern("nk_hsva_bv");

fn Color hsva_f(
  float h, 
  float s, 
  float v, 
  float a)
@extern("nk_hsva_f");

fn Color hsva_fv(
  float* hsva)
@extern("nk_hsva_fv");

fn void color_f(
  float* r, 
  float* g, 
  float* b, 
  float* a, 
  Color)
@extern("nk_color_f");

fn void color_fv(
  float* rgba_out, 
  Color)
@extern("nk_color_fv");

fn Colorf color_cf(
  Color)
@extern("nk_color_cf");

fn void color_d(
  double* r, 
  double* g, 
  double* b, 
  double* a, 
  Color)
@extern("nk_color_d");

fn void color_dv(
  double* rgba_out, 
  Color)
@extern("nk_color_dv");

fn Uint color_u32(
  Color)
@extern("nk_color_u32");

fn void color_hex_rgba(
  CChar* output, 
  Color)
@extern("nk_color_hex_rgba");

fn void color_hex_rgb(
  CChar* output, 
  Color)
@extern("nk_color_hex_rgb");

fn void color_hsv_i(
  CInt* out_h, 
  CInt* out_s, 
  CInt* out_v, 
  Color)
@extern("nk_color_hsv_i");

fn void color_hsv_b(
  Byte* out_h, 
  Byte* out_s, 
  Byte* out_v, 
  Color)
@extern("nk_color_hsv_b");

fn void color_hsv_iv(
  CInt* hsv_out, 
  Color)
@extern("nk_color_hsv_iv");

fn void color_hsv_bv(
  Byte* hsv_out, 
  Color)
@extern("nk_color_hsv_bv");

fn void color_hsv_f(
  float* out_h, 
  float* out_s, 
  float* out_v, 
  Color)
@extern("nk_color_hsv_f");

fn void color_hsv_fv(
  float* hsv_out, 
  Color)
@extern("nk_color_hsv_fv");

fn void color_hsva_i(
  CInt* h, 
  CInt* s, 
  CInt* v, 
  CInt* a, 
  Color)
@extern("nk_color_hsva_i");

fn void color_hsva_b(
  Byte* h, 
  Byte* s, 
  Byte* v, 
  Byte* a, 
  Color)
@extern("nk_color_hsva_b");

fn void color_hsva_iv(
  CInt* hsva_out, 
  Color)
@extern("nk_color_hsva_iv");

fn void color_hsva_bv(
  Byte* hsva_out, 
  Color)
@extern("nk_color_hsva_bv");

fn void color_hsva_f(
  float* out_h, 
  float* out_s, 
  float* out_v, 
  float* out_a, 
  Color)
@extern("nk_color_hsva_f");

fn void color_hsva_fv(
  float* hsva_out, 
  Color)
@extern("nk_color_hsva_fv");

fn Handle handle_ptr(
  void*)
@extern("nk_handle_ptr");

fn Handle handle_id(
  CInt)
@extern("nk_handle_id");

fn Image image_handle(
  Handle)
@extern("nk_image_handle");

fn Image image_ptr(
  void*)
@extern("nk_image_ptr");

fn Image image_id(
  CInt)
@extern("nk_image_id");

fn Bool image_is_subimage(
  Image* img)
@extern("nk_image_is_subimage");

fn Image subimage_ptr(
  void*, 
  Ushort w, 
  Ushort h, 
  Rect sub_region)
@extern("nk_subimage_ptr");

fn Image subimage_id(
  CInt, 
  Ushort w, 
  Ushort h, 
  Rect sub_region)
@extern("nk_subimage_id");

fn Image subimage_handle(
  Handle, 
  Ushort w, 
  Ushort h, 
  Rect sub_region)
@extern("nk_subimage_handle");

fn NineSlice nine_slice_handle(
  Handle, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_nine_slice_handle");

fn NineSlice nine_slice_ptr(
  void*, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_nine_slice_ptr");

fn NineSlice nine_slice_id(
  CInt, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_nine_slice_id");

fn CInt nine_slice_is_sub9slice(
  NineSlice* img)
@extern("nk_nine_slice_is_sub9slice");

fn NineSlice sub9slice_ptr(
  void*, 
  Ushort w, 
  Ushort h, 
  Rect sub_region, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_sub9slice_ptr");

fn NineSlice sub9slice_id(
  CInt, 
  Ushort w, 
  Ushort h, 
  Rect sub_region, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_sub9slice_id");

fn NineSlice sub9slice_handle(
  Handle, 
  Ushort w, 
  Ushort h, 
  Rect sub_region, 
  Ushort l, 
  Ushort t, 
  Ushort r, 
  Ushort b)
@extern("nk_sub9slice_handle");

fn Hash murmur_hash(
  void* key, 
  CInt len, 
  Hash seed)
@extern("nk_murmur_hash");

fn void triangle_from_direction(
  Vec2* result, 
  Rect r, 
  float pad_x, 
  float pad_y, 
  Heading)
@extern("nk_triangle_from_direction");

fn Vec2 vec2(
  float x, 
  float y)
@extern("nk_vec2");

fn Vec2 vec2i(
  CInt x, 
  CInt y)
@extern("nk_vec2i");

fn Vec2 vec2v(
  float* xy)
@extern("nk_vec2v");

fn Vec2 vec2iv(
  CInt* xy)
@extern("nk_vec2iv");

fn Rect get_null_rect()
@extern("nk_get_null_rect");

fn Rect rect(
  float x, 
  float y, 
  float w, 
  float h)
@extern("nk_rect");

fn Rect recti(
  CInt x, 
  CInt y, 
  CInt w, 
  CInt h)
@extern("nk_recti");

fn Rect recta(
  Vec2 pos, 
  Vec2 size)
@extern("nk_recta");

fn Rect rectv(
  float* xywh)
@extern("nk_rectv");

fn Rect rectiv(
  CInt* xywh)
@extern("nk_rectiv");

fn Vec2 rect_pos(
  Rect)
@extern("nk_rect_pos");

fn Vec2 rect_size(
  Rect)
@extern("nk_rect_size");

fn CInt strlen(
  CChar* str)
@extern("nk_strlen");

fn CInt stricmp(
  CChar* s1, 
  CChar* s2)
@extern("nk_stricmp");

fn CInt stricmpn(
  CChar* s1, 
  CChar* s2, 
  CInt n)
@extern("nk_stricmpn");

fn CInt strtoi(
  CChar* str, 
  CChar** endptr)
@extern("nk_strtoi");

fn float strtof(
  CChar* str, 
  CChar** endptr)
@extern("nk_strtof");

fn double strtod(
  CChar* str, 
  CChar** endptr)
@extern("nk_strtod");

fn CInt strfilter(
  CChar* text, 
  CChar* regexp)
@extern("nk_strfilter");

fn CInt strmatch_fuzzy_string(
  CChar* str, 
  CChar* pattern, 
  CInt* out_score)
@extern("nk_strmatch_fuzzy_string");

fn CInt strmatch_fuzzy_text(
  CChar* txt, 
  CInt txt_len, 
  CChar* pattern, 
  CInt* out_score)
@extern("nk_strmatch_fuzzy_text");

fn CInt utf_decode(
  CChar*, 
  Rune*, 
  CInt)
@extern("nk_utf_decode");

fn CInt utf_encode(
  Rune, 
  CChar*, 
  CInt)
@extern("nk_utf_encode");

fn CInt utf_len(
  CChar*, 
  CInt byte_len)
@extern("nk_utf_len");

fn CChar* utf_at(
  CChar* buffer, 
  CInt length, 
  CInt index, 
  Rune* unicode, 
  CInt* len)
@extern("nk_utf_at");

alias TextWidthF = fn float(
  Handle, 
  float h, 
  CChar*, 
  CInt len);

alias QueryFontGlyphF = fn void(
  Handle handle, 
  float font_height, 
  UserFontGlyph* glyph, 
  Rune codepoint, 
  Rune next_codepoint);

struct UserFontGlyph {
  Vec2[2] uv;
  Vec2 offset;
  float width;
  float height;
  float xadvance;
}

struct UserFont {
  Handle userdata;
  float height;
  TextWidthF width;
}

struct MemoryStatus {
  void* memory;
  CUInt type;
  Size size;
  Size allocated;
  Size needed;
  Size calls;
}

typedef AllocationType = inline CUInt;
const AllocationType BUFFER_FIXED = 0;
const AllocationType BUFFER_DYNAMIC = 1;

typedef BufferAllocationType = inline CUInt;
const BufferAllocationType BUFFER_FRONT = 0;
const BufferAllocationType BUFFER_BACK = 1;
const BufferAllocationType BUFFER_MAX = 2;

struct BufferMarker {
  Bool active;
  Size offset;
}

struct Memory {
  void* ptr;
  Size size;
}

struct Buffer {
  BufferMarker[2] marker;
  Allocator pool;
  AllocationType type;
  Memory memory;
  float grow_factor;
  Size allocated;
  Size needed;
  Size calls;
  Size size;
}

fn void buffer_init(
  Buffer*, 
  Allocator*, 
  Size size)
@extern("nk_buffer_init");

fn void buffer_init_fixed(
  Buffer*, 
  void* memory, 
  Size size)
@extern("nk_buffer_init_fixed");

fn void buffer_info(
  MemoryStatus*, 
  Buffer*)
@extern("nk_buffer_info");

fn void buffer_push(
  Buffer*, 
  BufferAllocationType type, 
  void* memory, 
  Size size, 
  Size align)
@extern("nk_buffer_push");

fn void buffer_mark(
  Buffer*, 
  BufferAllocationType type)
@extern("nk_buffer_mark");

fn void buffer_reset(
  Buffer*, 
  BufferAllocationType type)
@extern("nk_buffer_reset");

fn void buffer_clear(
  Buffer*)
@extern("nk_buffer_clear");

fn void buffer_free(
  Buffer*)
@extern("nk_buffer_free");

fn void* buffer_memory(
  Buffer*)
@extern("nk_buffer_memory");

fn void* buffer_memory_const(
  Buffer*)
@extern("nk_buffer_memory_const");

fn Size buffer_total(
  Buffer*)
@extern("nk_buffer_total");

struct Str {
  Buffer buffer;
  CInt len;
}

fn void str_init(
  Str*, 
  Allocator*, 
  Size size)
@extern("nk_str_init");

fn void str_init_fixed(
  Str*, 
  void* memory, 
  Size size)
@extern("nk_str_init_fixed");

fn void str_clear(
  Str*)
@extern("nk_str_clear");

fn void str_free(
  Str*)
@extern("nk_str_free");

fn CInt str_append_text_char(
  Str*, 
  CChar*, 
  CInt)
@extern("nk_str_append_text_char");

fn CInt str_append_str_char(
  Str*, 
  CChar*)
@extern("nk_str_append_str_char");

fn CInt str_append_text_utf8(
  Str*, 
  CChar*, 
  CInt)
@extern("nk_str_append_text_utf8");

fn CInt str_append_str_utf8(
  Str*, 
  CChar*)
@extern("nk_str_append_str_utf8");

fn CInt str_append_text_runes(
  Str*, 
  Rune*, 
  CInt)
@extern("nk_str_append_text_runes");

fn CInt str_append_str_runes(
  Str*, 
  Rune*)
@extern("nk_str_append_str_runes");

fn CInt str_insert_at_char(
  Str*, 
  CInt pos, 
  CChar*, 
  CInt)
@extern("nk_str_insert_at_char");

fn CInt str_insert_at_rune(
  Str*, 
  CInt pos, 
  CChar*, 
  CInt)
@extern("nk_str_insert_at_rune");

fn CInt str_insert_text_char(
  Str*, 
  CInt pos, 
  CChar*, 
  CInt)
@extern("nk_str_insert_text_char");

fn CInt str_insert_str_char(
  Str*, 
  CInt pos, 
  CChar*)
@extern("nk_str_insert_str_char");

fn CInt str_insert_text_utf8(
  Str*, 
  CInt pos, 
  CChar*, 
  CInt)
@extern("nk_str_insert_text_utf8");

fn CInt str_insert_str_utf8(
  Str*, 
  CInt pos, 
  CChar*)
@extern("nk_str_insert_str_utf8");

fn CInt str_insert_text_runes(
  Str*, 
  CInt pos, 
  Rune*, 
  CInt)
@extern("nk_str_insert_text_runes");

fn CInt str_insert_str_runes(
  Str*, 
  CInt pos, 
  Rune*)
@extern("nk_str_insert_str_runes");

fn void str_remove_chars(
  Str*, 
  CInt len)
@extern("nk_str_remove_chars");

fn void str_remove_runes(
  Str* str, 
  CInt len)
@extern("nk_str_remove_runes");

fn void str_delete_chars(
  Str*, 
  CInt pos, 
  CInt len)
@extern("nk_str_delete_chars");

fn void str_delete_runes(
  Str*, 
  CInt pos, 
  CInt len)
@extern("nk_str_delete_runes");

fn CChar* str_at_char(
  Str*, 
  CInt pos)
@extern("nk_str_at_char");

fn CChar* str_at_rune(
  Str*, 
  CInt pos, 
  Rune* unicode, 
  CInt* len)
@extern("nk_str_at_rune");

fn Rune str_rune_at(
  Str*, 
  CInt pos)
@extern("nk_str_rune_at");

fn CChar* str_at_char_const(
  Str*, 
  CInt pos)
@extern("nk_str_at_char_const");

fn CChar* str_at_const(
  Str*, 
  CInt pos, 
  Rune* unicode, 
  CInt* len)
@extern("nk_str_at_const");

fn CChar* str_get(
  Str*)
@extern("nk_str_get");

fn CChar* str_get_const(
  Str*)
@extern("nk_str_get_const");

fn CInt str_len(
  Str*)
@extern("nk_str_len");

fn CInt str_len_char(
  Str*)
@extern("nk_str_len_char");

struct Clipboard {
  Handle userdata;
  PluginPaste paste;
  PluginCopy copy;
}

struct TextUndoRecord {
  CInt where;
  CShort insert_length;
  CShort delete_length;
  CShort char_storage;
}

struct TextUndoState {
  TextUndoRecord[99] undo_rec;
  Rune[999] undo_char;
  CShort undo_point;
  CShort redo_point;
  CShort undo_char_point;
  CShort redo_char_point;
}

typedef TextEditType = inline CUInt;
const TextEditType TEXT_EDIT_SINGLE_LINE = 0;
const TextEditType TEXT_EDIT_MULTI_LINE = 1;

typedef TextEditMode = inline CUInt;
const TextEditMode TEXT_EDIT_MODE_VIEW = 0;
const TextEditMode TEXT_EDIT_MODE_INSERT = 1;
const TextEditMode TEXT_EDIT_MODE_REPLACE = 2;

struct TextEdit {
  Clipboard clip;
  Str string;
  PluginFilter filter;
  Vec2 scrollbar;
  CInt cursor;
  CInt select_start;
  CInt select_end;
  char mode;
  char cursor_at_end_of_line;
  char initialized;
  char has_preferred_x;
  char single_line;
  char active;
  char padding1;
  float preferred_x;
  TextUndoState undo;
}

fn Bool filter_default(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_default");

fn Bool filter_ascii(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_ascii");

fn Bool filter_float(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_float");

fn Bool filter_decimal(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_decimal");

fn Bool filter_hex(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_hex");

fn Bool filter_oct(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_oct");

fn Bool filter_binary(
  TextEdit*, 
  Rune unicode)
@extern("nk_filter_binary");

fn void textedit_init(
  TextEdit*, 
  Allocator*, 
  Size size)
@extern("nk_textedit_init");

fn void textedit_init_fixed(
  TextEdit*, 
  void* memory, 
  Size size)
@extern("nk_textedit_init_fixed");

fn void textedit_free(
  TextEdit*)
@extern("nk_textedit_free");

fn void textedit_text(
  TextEdit*, 
  CChar*, 
  CInt total_len)
@extern("nk_textedit_text");

fn void textedit_delete(
  TextEdit*, 
  CInt where, 
  CInt len)
@extern("nk_textedit_delete");

fn void textedit_delete_selection(
  TextEdit*)
@extern("nk_textedit_delete_selection");

fn void textedit_select_all(
  TextEdit*)
@extern("nk_textedit_select_all");

fn Bool textedit_cut(
  TextEdit*)
@extern("nk_textedit_cut");

fn Bool textedit_paste(
  TextEdit*, 
  CChar*, 
  CInt len)
@extern("nk_textedit_paste");

fn void textedit_undo(
  TextEdit*)
@extern("nk_textedit_undo");

fn void textedit_redo(
  TextEdit*)
@extern("nk_textedit_redo");

typedef CommandType = inline CUInt;
const CommandType COMMAND_NOP = 0;
const CommandType COMMAND_SCISSOR = 1;
const CommandType COMMAND_LINE = 2;
const CommandType COMMAND_CURVE = 3;
const CommandType COMMAND_RECT = 4;
const CommandType COMMAND_RECT_FILLED = 5;
const CommandType COMMAND_RECT_MULTI_COLOR = 6;
const CommandType COMMAND_CIRCLE = 7;
const CommandType COMMAND_CIRCLE_FILLED = 8;
const CommandType COMMAND_ARC = 9;
const CommandType COMMAND_ARC_FILLED = 10;
const CommandType COMMAND_TRIANGLE = 11;
const CommandType COMMAND_TRIANGLE_FILLED = 12;
const CommandType COMMAND_POLYGON = 13;
const CommandType COMMAND_POLYGON_FILLED = 14;
const CommandType COMMAND_POLYLINE = 15;
const CommandType COMMAND_TEXT = 16;
const CommandType COMMAND_IMAGE = 17;
const CommandType COMMAND_CUSTOM = 18;

struct Command {
  CommandType type;
  Size next;
  Handle userdata;
}

struct CommandScissor {
  Command header;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
}

struct CommandLine {
  Command header;
  CUShort line_thickness;
  Vec2i begin;
  Vec2i end;
  Color color;
}

struct CommandCurve {
  Command header;
  CUShort line_thickness;
  Vec2i begin;
  Vec2i end;
  Vec2i[2] ctrl;
  Color color;
}

struct CommandRect {
  Command header;
  CUShort rounding;
  CUShort line_thickness;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Color color;
}

struct CommandRectFilled {
  Command header;
  CUShort rounding;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Color color;
}

struct CommandRectMultiColor {
  Command header;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Color left;
  Color top;
  Color bottom;
  Color right;
}

struct CommandTriangle {
  Command header;
  CUShort line_thickness;
  Vec2i a;
  Vec2i b;
  Vec2i c;
  Color color;
}

struct CommandTriangleFilled {
  Command header;
  Vec2i a;
  Vec2i b;
  Vec2i c;
  Color color;
}

struct CommandCircle {
  Command header;
  CShort x;
  CShort y;
  CUShort line_thickness;
  CUShort w;
  CUShort h;
  Color color;
}

struct CommandCircleFilled {
  Command header;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Color color;
}

struct CommandArc {
  Command header;
  CShort cx;
  CShort cy;
  CUShort r;
  CUShort line_thickness;
  float[2] a;
  Color color;
}

struct CommandArcFilled {
  Command header;
  CShort cx;
  CShort cy;
  CUShort r;
  float[2] a;
  Color color;
}

struct CommandPolygon {
  Command header;
  Color color;
  CUShort line_thickness;
  CUShort point_count;
  Vec2i[1] points;
}

struct CommandPolygonFilled {
  Command header;
  Color color;
  CUShort point_count;
  Vec2i[1] points;
}

struct CommandPolyline {
  Command header;
  Color color;
  CUShort line_thickness;
  CUShort point_count;
  Vec2i[1] points;
}

struct CommandImage {
  Command header;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Image img;
  Color col;
}

alias CommandCustomCallback = fn void(
  void* canvas, 
  CShort x, 
  CShort y, 
  CUShort w, 
  CUShort h, 
  Handle callback_data);

struct CommandCustom {
  Command header;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  Handle callback_data;
  CommandCustomCallback callback;
}

struct CommandText {
  Command header;
  UserFont* font;
  Color background;
  Color foreground;
  CShort x;
  CShort y;
  CUShort w;
  CUShort h;
  float height;
  CInt length;
  CChar[2] string;
}

typedef CommandClipping = inline CUInt;
const CommandClipping CLIPPING_OFF = FALSE;
const CommandClipping CLIPPING_ON = TRUE;

struct CommandBuffer {
  Buffer* base;
  Rect clip;
  CInt use_clipping;
  Handle userdata;
  Size begin;
  Size end;
  Size last;
}

fn void stroke_line(
  CommandBuffer* b, 
  float x0, 
  float y0, 
  float x1, 
  float y1, 
  float line_thickness, 
  Color)
@extern("nk_stroke_line");

fn void stroke_curve(
  CommandBuffer*, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float line_thickness, 
  Color)
@extern("nk_stroke_curve");

fn void stroke_rect(
  CommandBuffer*, 
  Rect, 
  float rounding, 
  float line_thickness, 
  Color)
@extern("nk_stroke_rect");

fn void stroke_circle(
  CommandBuffer*, 
  Rect, 
  float line_thickness, 
  Color)
@extern("nk_stroke_circle");

fn void stroke_arc(
  CommandBuffer*, 
  float cx, 
  float cy, 
  float radius, 
  float a_min, 
  float a_max, 
  float line_thickness, 
  Color)
@extern("nk_stroke_arc");

fn void stroke_triangle(
  CommandBuffer*, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float, 
  float line_thichness, 
  Color)
@extern("nk_stroke_triangle");

fn void stroke_polyline(
  CommandBuffer*, 
  float* points, 
  CInt point_count, 
  float line_thickness, 
  Color col)
@extern("nk_stroke_polyline");

fn void stroke_polygon(
  CommandBuffer*, 
  float* points, 
  CInt point_count, 
  float line_thickness, 
  Color)
@extern("nk_stroke_polygon");

fn void fill_rect(
  CommandBuffer*, 
  Rect, 
  float rounding, 
  Color)
@extern("nk_fill_rect");

fn void fill_rect_multi_color(
  CommandBuffer*, 
  Rect, 
  Color left, 
  Color top, 
  Color right, 
  Color bottom)
@extern("nk_fill_rect_multi_color");

fn void fill_circle(
  CommandBuffer*, 
  Rect, 
  Color)
@extern("nk_fill_circle");

fn void fill_arc(
  CommandBuffer*, 
  float cx, 
  float cy, 
  float radius, 
  float a_min, 
  float a_max, 
  Color)
@extern("nk_fill_arc");

fn void fill_triangle(
  CommandBuffer*, 
  float x0, 
  float y0, 
  float x1, 
  float y1, 
  float x2, 
  float y2, 
  Color)
@extern("nk_fill_triangle");

fn void fill_polygon(
  CommandBuffer*, 
  float* points, 
  CInt point_count, 
  Color)
@extern("nk_fill_polygon");

fn void draw_image(
  CommandBuffer*, 
  Rect, 
  Image*, 
  Color)
@extern("nk_draw_image");

fn void draw_nine_slice(
  CommandBuffer*, 
  Rect, 
  NineSlice*, 
  Color)
@extern("nk_draw_nine_slice");

fn void draw_text(
  CommandBuffer*, 
  Rect, 
  CChar* text, 
  CInt len, 
  UserFont*, 
  Color, 
  Color)
@extern("nk_draw_text");

fn void push_scissor(
  CommandBuffer*, 
  Rect)
@extern("nk_push_scissor");

fn void push_custom(
  CommandBuffer*, 
  Rect, 
  CommandCustomCallback, 
  Handle usr)
@extern("nk_push_custom");

struct MouseButton {
  Bool down;
  CUInt clicked;
  Vec2 clicked_pos;
}

struct Mouse {
  MouseButton[4] buttons;
  Vec2 pos;
  Vec2 prev;
  Vec2 delta;
  Vec2 scroll_delta;
  char grab;
  char grabbed;
  char ungrab;
}

struct Key {
  Bool down;
  CUInt clicked;
}

struct Keyboard {
  Key[30] keys;
  CChar[16] text;
  CInt text_len;
}

struct Input {
  Keyboard keyboard;
  Mouse mouse;
}

fn Bool input_has_mouse_click(
  Input*, 
  Buttons)
@extern("nk_input_has_mouse_click");

fn Bool input_has_mouse_click_in_rect(
  Input*, 
  Buttons, 
  Rect)
@extern("nk_input_has_mouse_click_in_rect");

fn Bool input_has_mouse_click_in_button_rect(
  Input*, 
  Buttons, 
  Rect)
@extern("nk_input_has_mouse_click_in_button_rect");

fn Bool input_has_mouse_click_down_in_rect(
  Input*, 
  Buttons, 
  Rect, 
  Bool down)
@extern("nk_input_has_mouse_click_down_in_rect");

fn Bool input_is_mouse_click_in_rect(
  Input*, 
  Buttons, 
  Rect)
@extern("nk_input_is_mouse_click_in_rect");

fn Bool input_is_mouse_click_down_in_rect(
  Input* i, 
  Buttons id, 
  Rect b, 
  Bool down)
@extern("nk_input_is_mouse_click_down_in_rect");

fn Bool input_any_mouse_click_in_rect(
  Input*, 
  Rect)
@extern("nk_input_any_mouse_click_in_rect");

fn Bool input_is_mouse_prev_hovering_rect(
  Input*, 
  Rect)
@extern("nk_input_is_mouse_prev_hovering_rect");

fn Bool input_is_mouse_hovering_rect(
  Input*, 
  Rect)
@extern("nk_input_is_mouse_hovering_rect");

fn Bool input_mouse_clicked(
  Input*, 
  Buttons, 
  Rect)
@extern("nk_input_mouse_clicked");

fn Bool input_is_mouse_down(
  Input*, 
  Buttons)
@extern("nk_input_is_mouse_down");

fn Bool input_is_mouse_pressed(
  Input*, 
  Buttons)
@extern("nk_input_is_mouse_pressed");

fn Bool input_is_mouse_released(
  Input*, 
  Buttons)
@extern("nk_input_is_mouse_released");

fn Bool input_is_key_pressed(
  Input*, 
  Keys)
@extern("nk_input_is_key_pressed");

fn Bool input_is_key_released(
  Input*, 
  Keys)
@extern("nk_input_is_key_released");

fn Bool input_is_key_down(
  Input*, 
  Keys)
@extern("nk_input_is_key_down");

typedef StyleItemType = inline CUInt;
const StyleItemType STYLE_ITEM_COLOR = 0;
const StyleItemType STYLE_ITEM_IMAGE = 1;
const StyleItemType STYLE_ITEM_NINE_SLICE = 2;

union StyleItemData {
  Color color;
  Image image;
  NineSlice slice;
}

struct StyleItem {
  StyleItemType type;
  StyleItemData data;
}

struct StyleText {
  Color color;
  Vec2 padding;
  float color_factor;
  float disabled_factor;
}

alias UnnamedPFN3 @private = fn void(
  CommandBuffer*, 
  Handle userdata);

struct StyleButton {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  float color_factor_background;
  Color text_background;
  Color text_normal;
  Color text_hover;
  Color text_active;
  Flags text_alignment;
  float color_factor_text;
  float border;
  float rounding;
  Vec2 padding;
  Vec2 image_padding;
  Vec2 touch_padding;
  float disabled_factor;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleToggle {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  StyleItem cursor_normal;
  StyleItem cursor_hover;
  Color text_normal;
  Color text_hover;
  Color text_active;
  Color text_background;
  Flags text_alignment;
  Vec2 padding;
  Vec2 touch_padding;
  float spacing;
  float border;
  float color_factor;
  float disabled_factor;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleSelectable {
  StyleItem normal;
  StyleItem hover;
  StyleItem pressed;
  StyleItem normal_active;
  StyleItem hover_active;
  StyleItem pressed_active;
  Color text_normal;
  Color text_hover;
  Color text_pressed;
  Color text_normal_active;
  Color text_hover_active;
  Color text_pressed_active;
  Color text_background;
  Flags text_alignment;
  float rounding;
  Vec2 padding;
  Vec2 touch_padding;
  Vec2 image_padding;
  float color_factor;
  float disabled_factor;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleSlider {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  Color bar_normal;
  Color bar_hover;
  Color bar_active;
  Color bar_filled;
  StyleItem cursor_normal;
  StyleItem cursor_hover;
  StyleItem cursor_active;
  float border;
  float rounding;
  float bar_height;
  Vec2 padding;
  Vec2 spacing;
  Vec2 cursor_size;
  float color_factor;
  float disabled_factor;
  CInt show_buttons;
  StyleButton inc_button;
  StyleButton dec_button;
  SymbolType inc_symbol;
  SymbolType dec_symbol;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleKnob {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  Color knob_normal;
  Color knob_hover;
  Color knob_active;
  Color knob_border_color;
  Color cursor_normal;
  Color cursor_hover;
  Color cursor_active;
  float border;
  float knob_border;
  Vec2 padding;
  Vec2 spacing;
  float cursor_width;
  float color_factor;
  float disabled_factor;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleProgress {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  StyleItem cursor_normal;
  StyleItem cursor_hover;
  StyleItem cursor_active;
  Color cursor_border_color;
  float rounding;
  float border;
  float cursor_border;
  float cursor_rounding;
  Vec2 padding;
  float color_factor;
  float disabled_factor;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleScrollbar {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  StyleItem cursor_normal;
  StyleItem cursor_hover;
  StyleItem cursor_active;
  Color cursor_border_color;
  float border;
  float rounding;
  float border_cursor;
  float rounding_cursor;
  Vec2 padding;
  float color_factor;
  float disabled_factor;
  CInt show_buttons;
  StyleButton inc_button;
  StyleButton dec_button;
  SymbolType inc_symbol;
  SymbolType dec_symbol;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleEdit {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  StyleScrollbar scrollbar;
  Color cursor_normal;
  Color cursor_hover;
  Color cursor_text_normal;
  Color cursor_text_hover;
  Color text_normal;
  Color text_hover;
  Color text_active;
  Color selected_normal;
  Color selected_hover;
  Color selected_text_normal;
  Color selected_text_hover;
  float border;
  float rounding;
  float cursor_size;
  Vec2 scrollbar_size;
  Vec2 padding;
  float row_padding;
  float color_factor;
  float disabled_factor;
}

struct StyleProperty {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  Color label_normal;
  Color label_hover;
  Color label_active;
  SymbolType sym_left;
  SymbolType sym_right;
  float border;
  float rounding;
  Vec2 padding;
  float color_factor;
  float disabled_factor;
  StyleEdit edit;
  StyleButton inc_button;
  StyleButton dec_button;
  Handle userdata;
  UnnamedPFN3 draw_begin;
  UnnamedPFN3 draw_end;
}

struct StyleChart {
  StyleItem background;
  Color border_color;
  Color selected_color;
  Color color;
  float border;
  float rounding;
  Vec2 padding;
  float color_factor;
  float disabled_factor;
  Bool show_markers;
}

struct StyleCombo {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  Color border_color;
  Color label_normal;
  Color label_hover;
  Color label_active;
  Color symbol_normal;
  Color symbol_hover;
  Color symbol_active;
  StyleButton button;
  SymbolType sym_normal;
  SymbolType sym_hover;
  SymbolType sym_active;
  float border;
  float rounding;
  Vec2 content_padding;
  Vec2 button_padding;
  Vec2 spacing;
  float color_factor;
  float disabled_factor;
}

struct StyleTab {
  StyleItem background;
  Color border_color;
  Color text;
  StyleButton tab_maximize_button;
  StyleButton tab_minimize_button;
  StyleButton node_maximize_button;
  StyleButton node_minimize_button;
  SymbolType sym_minimize;
  SymbolType sym_maximize;
  float border;
  float rounding;
  float indent;
  Vec2 padding;
  Vec2 spacing;
  float color_factor;
  float disabled_factor;
}

typedef StyleHeaderAlign = inline CUInt;
const StyleHeaderAlign HEADER_LEFT = 0;
const StyleHeaderAlign HEADER_RIGHT = 1;

struct StyleWindowHeader {
  StyleItem normal;
  StyleItem hover;
  StyleItem active;
  StyleButton close_button;
  StyleButton minimize_button;
  SymbolType close_symbol;
  SymbolType minimize_symbol;
  SymbolType maximize_symbol;
  Color label_normal;
  Color label_hover;
  Color label_active;
  StyleHeaderAlign align;
  Vec2 padding;
  Vec2 label_padding;
  Vec2 spacing;
}

struct StyleWindow {
  StyleWindowHeader header;
  StyleItem fixed_background;
  Color background;
  Color border_color;
  Color popup_border_color;
  Color combo_border_color;
  Color contextual_border_color;
  Color menu_border_color;
  Color group_border_color;
  Color tooltip_border_color;
  StyleItem scaler;
  float border;
  float combo_border;
  float contextual_border;
  float menu_border;
  float group_border;
  float tooltip_border;
  float popup_border;
  float min_row_height_padding;
  float rounding;
  Vec2 spacing;
  Vec2 scrollbar_size;
  Vec2 min_size;
  Vec2 padding;
  Vec2 group_padding;
  Vec2 popup_padding;
  Vec2 combo_padding;
  Vec2 contextual_padding;
  Vec2 menu_padding;
  Vec2 tooltip_padding;
}

struct Style {
  UserFont* font;
  Cursor*[7] cursors;
  Cursor* cursor_active;
  Cursor* cursor_last;
  CInt cursor_visible;
  StyleText text;
  StyleButton button;
  StyleButton contextual_button;
  StyleButton menu_button;
  StyleToggle option;
  StyleToggle checkbox;
  StyleSelectable selectable;
  StyleSlider slider;
  StyleKnob knob;
  StyleProgress progress;
  StyleProperty property;
  StyleEdit edit;
  StyleChart chart;
  StyleScrollbar scrollh;
  StyleScrollbar scrollv;
  StyleTab tab;
  StyleCombo combo;
  StyleWindow window;
}

fn StyleItem style_item_color(
  Color)
@extern("nk_style_item_color");

fn StyleItem style_item_image(
  Image img)
@extern("nk_style_item_image");

fn StyleItem style_item_nine_slice(
  NineSlice slice)
@extern("nk_style_item_nine_slice");

fn StyleItem style_item_hide()
@extern("nk_style_item_hide");

typedef PanelType = inline CUInt;
const PanelType PANEL_NONE = 0;
const PanelType PANEL_WINDOW = @flag(0);
const PanelType PANEL_GROUP = @flag(1);
const PanelType PANEL_POPUP = @flag(2);
const PanelType PANEL_CONTEXTUAL = @flag(4);
const PanelType PANEL_COMBO = @flag(5);
const PanelType PANEL_MENU = @flag(6);
const PanelType PANEL_TOOLTIP = @flag(7);

typedef PanelSet = inline CUInt;
const PanelSet PANEL_SET_NONBLOCK = PANEL_CONTEXTUAL|PANEL_COMBO|PANEL_MENU|PANEL_TOOLTIP;
const PanelSet PANEL_SET_POPUP = PANEL_SET_NONBLOCK|PANEL_POPUP;
const PanelSet PANEL_SET_SUB = PANEL_SET_POPUP|PANEL_GROUP;

struct ChartSlot {
  ChartType type;
  Color color;
  Color highlight;
  float min;
  float max;
  float range;
  CInt count;
  Vec2 last;
  CInt index;
  Bool show_markers;
}

struct Chart {
  CInt slot;
  float x;
  float y;
  float w;
  float h;
  ChartSlot[4] slots;
}

typedef PanelRowLayoutType = inline CUInt;
const PanelRowLayoutType LAYOUT_DYNAMIC_FIXED = 0;
const PanelRowLayoutType LAYOUT_DYNAMIC_ROW = 1;
const PanelRowLayoutType LAYOUT_DYNAMIC_FREE = 2;
const PanelRowLayoutType LAYOUT_DYNAMIC = 3;
const PanelRowLayoutType LAYOUT_STATIC_FIXED = 4;
const PanelRowLayoutType LAYOUT_STATIC_ROW = 5;
const PanelRowLayoutType LAYOUT_STATIC_FREE = 6;
const PanelRowLayoutType LAYOUT_STATIC = 7;
const PanelRowLayoutType LAYOUT_TEMPLATE = 8;
const PanelRowLayoutType LAYOUT_COUNT = 9;

struct RowLayout {
  PanelRowLayoutType type;
  CInt index;
  float height;
  float min_height;
  CInt columns;
  float* ratio;
  float item_width;
  float item_height;
  float item_offset;
  float filled;
  Rect item;
  CInt tree_depth;
  float[16] templates;
}

struct PopupBuffer {
  Size begin;
  Size parent;
  Size last;
  Size end;
  Bool active;
}

struct MenuState {
  float x;
  float y;
  float w;
  float h;
  Scroll offset;
}

struct Panel {
  PanelType type;
  Flags flags;
  Rect bounds;
  Uint* offset_x;
  Uint* offset_y;
  float at_x;
  float at_y;
  float max_x;
  float footer_height;
  float header_height;
  float border;
  CUInt has_scrolling;
  Rect clip;
  MenuState menu;
  RowLayout row;
  Chart chart;
  CommandBuffer* buffer;
  Panel* parent;
}

typedef WindowFlags = inline CUInt;
const WindowFlags WINDOW_PRIVATE = @flag(11);
const WindowFlags WINDOW_DYNAMIC = WINDOW_PRIVATE;
const WindowFlags WINDOW_ROM = @flag(12);
const WindowFlags WINDOW_NOT_INTERACTIVE = WINDOW_ROM|WINDOW_NO_INPUT;
const WindowFlags WINDOW_HIDDEN = @flag(13);
const WindowFlags WINDOW_CLOSED = @flag(14);
const WindowFlags WINDOW_MINIMIZED = @flag(15);
const WindowFlags WINDOW_REMOVE_ROM = @flag(16);

struct PopupState {
  Window* win;
  PanelType type;
  PopupBuffer buf;
  Hash name;
  Bool active;
  CUInt combo_count;
  CUInt con_count;
  CUInt con_old;
  CUInt active_con;
  Rect header;
}

struct EditState {
  Hash name;
  CUInt seq;
  CUInt old;
  CInt active;
  CInt prev;
  CInt cursor;
  CInt sel_start;
  CInt sel_end;
  Scroll scrollbar;
  char mode;
  char single_line;
}

struct PropertyState {
  CInt active;
  CInt prev;
  CChar[64] buffer;
  CInt length;
  CInt cursor;
  CInt select_start;
  CInt select_end;
  Hash name;
  CUInt seq;
  CUInt old;
  CInt state;
}

struct Window {
  CUInt seq;
  Hash name;
  CChar[64] name_string;
  Flags flags;
  Rect bounds;
  Scroll scrollbar;
  CommandBuffer buffer;
  Panel* layout;
  float scrollbar_hiding_timer;
  PropertyState property;
  PopupState popup;
  EditState edit;
  CUInt scrolled;
  Bool widgets_disabled;
  Table* tables;
  CUInt table_count;
  Window* next;
  Window* prev;
  Window* parent;
}

struct ConfigStackStyleItemElement {
  StyleItem* address;
  StyleItem old_value;
}

struct ConfigStackFloatElement {
  float* address;
  float old_value;
}

struct ConfigStackVec2Element {
  Vec2* address;
  Vec2 old_value;
}

struct ConfigStackFlagsElement {
  Flags* address;
  Flags old_value;
}

struct ConfigStackColorElement {
  Color* address;
  Color old_value;
}

struct ConfigStackUserFontElement {
  UserFont** address;
  UserFont* old_value;
}

struct ConfigStackButtonBehaviorElement {
  ButtonBehavior* address;
  ButtonBehavior old_value;
}

struct ConfigStackStyleItem {
  CInt head;
  ConfigStackStyleItemElement[16] elements;
}

struct ConfigStackFloat {
  CInt head;
  ConfigStackFloatElement[32] elements;
}

struct ConfigStackVec2 {
  CInt head;
  ConfigStackVec2Element[16] elements;
}

struct ConfigStackFlags {
  CInt head;
  ConfigStackFlagsElement[32] elements;
}

struct ConfigStackColor {
  CInt head;
  ConfigStackColorElement[32] elements;
}

struct ConfigStackUserFont {
  CInt head;
  ConfigStackUserFontElement[8] elements;
}

struct ConfigStackButtonBehavior {
  CInt head;
  ConfigStackButtonBehaviorElement[8] elements;
}

struct ConfigurationStacks {
  ConfigStackStyleItem style_items;
  ConfigStackFloat floats;
  ConfigStackVec2 vectors;
  ConfigStackFlags flags;
  ConfigStackColor colors;
  ConfigStackUserFont fonts;
  ConfigStackButtonBehavior button_behaviors;
}

struct Table {
  CUInt seq;
  CUInt size;
  Hash[60] keys;
  Uint[60] values;
  Table* next;
  Table* prev;
}

union PageData {
  Table tbl;
  Panel pan;
  Window win;
}

struct PageElement {
  PageData data;
  PageElement* next;
  PageElement* prev;
}

struct Page {
  CUInt size;
  Page* next;
  PageElement[1] win;
}

struct Pool {
  Allocator alloc;
  AllocationType type;
  CUInt page_count;
  Page* pages;
  PageElement* freelist;
  CUInt capacity;
  Size size;
  Size cap;
}

struct Context {
  Input input;
  Style style;
  Buffer memory;
  Clipboard clip;
  Flags last_widget_state;
  ButtonBehavior button_behavior;
  ConfigurationStacks stacks;
  float delta_time_seconds;
  Handle userdata;
  TextEdit text_edit;
  CommandBuffer overlay;
  CInt build;
  CInt use_pool;
  Pool pool;
  Window* begin;
  Window* end;
  Window* active;
  Window* current;
  PageElement* freelist;
  CUInt count;
  CUInt seq;
}
